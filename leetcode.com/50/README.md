# Pow(x, n)

Implement pow(*x*, *n*), which calculates *x* raised to the power *n* (x^n).



### Example 1:

```
Input: 2.00000, 10
Output: 1024.00000
```



### Example 2:

```
Input: 2.10000, 3
Output: 9.26100
```



### Example 3:

```
Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```



### Note:

- -100.0 < *x* < 100.0
- *n* is a 32-bit signed integer, within the range [−231, 231 − 1]



## Template

C++

```c++
class Solution {
public:
    double myPow(double x, int n) {
        
    }
};
```



Java

```java
class Solution {
    public double myPow(double x, int n) {
        
    }
}
```



Python

```python
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        
```



Python3

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        
```



C

```c
double myPow(double x, int n) {
    
}
```



C#

```csharp
public class Solution {
    public double MyPow(double x, int n) {
        
    }
}
```



Javascript

```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    
};
```



Ruby

```ruby
# @param {Float} x
# @param {Integer} n
# @return {Float}
def my_pow(x, n)
    
end
```



Swift

```swift
class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        
    }
}
```



Go

```go
func myPow(x float64, n int) float64 {
    
}
```



Scala

```scala
object Solution {
    def myPow(x: Double, n: Int): Double = {
        
    }
}
```



Kotlin

```kotlin
class Solution {
    fun myPow(x: Double, n: Int): Double {
        
    }
}
```



Rust

```rust
impl Solution {
    pub fn my_pow(x: f64, n: i32) -> f64 {
        
    }
}
```



PHP

```php
class Solution {

    /**
     * @param Float $x
     * @param Integer $n
     * @return Float
     */
    function myPow($x, $n) {
        
    }
}
```